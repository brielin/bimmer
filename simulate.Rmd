---
title: "simulate"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages
```{r}
require(MrNo)
require(foreach)
require(tibble)
require(dplyr)
require(Matrix)
require(ggplot2)
```

# Generate data. First looking only at TCE.
```{r warning=FALSE}
# Basic set-up for simulation.
N = 5000
M = 1000
D = 10
p_beta = 0.15
p_network = 0.15
niter = 100

plot_tibble <- foreach(i = 1:niter, .combine = bind_rows) %do% {
  # Randomly choose noise proportion.
  noise <- runif(1, 0, 1.0)
  dataset <- generate_dataset(N, M, D, noise = noise)
  Y_sds <- apply(dataset$Y, 2, sd)

  # Calculate the rank of R to track during simulations.
  eigenv_R <- eigen(dataset$R, only.values = TRUE)$values
  rank_R <- sum(abs(eigenv_R) > 1e-10)

  # Calculate the self-influence of each nose to track during simulations.
  R_obs = get_observed(dataset$R)
  self_norm = 1 + diag(R_obs)
  min_abs_self = min(abs(self_norm))
  min_self = min(self_norm)
  max_self = max(self_norm)

  # All calculations happen on per-normalized scale, so convert R here.
  R_tce = get_tce(R_obs, normalize=Y_sds)
  R_normed <- fit_exact(R_tce)

  # Split dataset into SNP selection and fitting.
  sample <- sample.int(n = N, size = floor(N/2), replace = FALSE)
  X_select = dataset$X[sample, ]
  Y_select = dataset$Y[sample, ]
  X_fit = dataset$X[-sample, ]
  Y_fit = dataset$Y[-sample, ]
  sumstats_select = generate_sumstats(X_select, Y_select, normalize = TRUE)
  sumstats_fit = generate_sumstats(X_fit, Y_fit, normalize = TRUE)

  # Select SNPs via sumstats and by cheating.
  selected <- select_snps(sumstats_select)
  selected_oracle <- select_snps_oracle(dataset$beta, sumstats_fit$p_value)
  
  # Run all combinations of MR method and fit method.
  foreach(mr_method = c("cheat", "mean", "ps", "aps", "raps"),
          .combine = bind_rows) %do% {
    foreach(fit_method = c("exact", "regularized"),
            .combine = bind_rows) %do% {
      tryCatch(
        {
          # For cheat, use oracle SNPs and profile score.
          if(mr_method == "cheat"){
            R_tce_hat <- fit_tce(sumstats_fit, selected_oracle, mr_method="ps")
          }
          else{
            R_tce_hat <- fit_tce(sumstats_fit, selected, mr_method=mr_method)
          }
          mae_tce <- mean(as.matrix(abs(R_tce - R_tce_hat)), na.rm=TRUE)
      
          # We might have some missing values, for now impute with true + noise.
          R_tce_hat[is.na(R_tce_hat)] = R_tce[is.na(R_tce_hat)] + 
            rnorm(sum(is.na(R_tce_hat)), sd = 1.5*mae_tce)
      
          fit_method_func <- switch(fit_method,
            exact = fit_exact,
            regularized = function(R_tce){
              fit_regularized_over_lambda(R_tce, R_normed)}
          )
          R_hat = fit_method_func(R_tce = R_tce_hat)
          mae_cde <- mean(as.matrix(abs(R_hat - R_normed)))
          tibble(noise = noise, min_abs_self = min_abs_self, rank_R = rank_R,
            mr_method = mr_method, fit_method = fit_method,
            mae_tce = mae_tce, mae_cde = mae_cde)
        },
        error = function(cond){
          tibble(noise = noise, min_abs_self = min_abs_self, rank_R = rank_R,
            mr_method = mr_method, fit_method = fit_method,
            mae_tce = NA, mae_cde = NA)
        })

    }
  }
}
plot_tibble = unite(plot_tibble, "mr_fit", c("mr_method", "fit_method"), sep = "_", remove = FALSE)
```


```{r}
well_cond = plot_tibble[plot_tibble[,"min_abs_self"] > 0.5,]
ggplot(well_cond, aes(noise, mae_tce, colour = mr_method)) + geom_point() + ylim(0, 0.5)
ggplot(well_cond, aes(noise, mae_cde, colour = mr_fit)) + geom_point() + ylim(0, 0.5)

ggplot(well_cond, aes(mr_method, mae_tce)) + geom_violin() + geom_jitter(height = 0, width = 0.1) + ylim(0, 0.5)
ggplot(well_cond, aes(mr_fit, mae_cde)) + geom_violin() + geom_jitter(height = 0, width = 0.1) + ylim(0, 0.5)
```
