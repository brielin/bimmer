---
title: "simulate"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages
```{r}
require(tidyverse)
require(foreach)
require(inspre)
require(devtools)
require(huge)
devtools::load_all()
```


```{r}
run_methods <- function(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient){
  R <- generate_network(D = D, graph = graph, prob = prob, g = g, v = v, orient = orient)
  dataset <- generate_dataset(N = N, D = D, M_total = M_total, M_s = M_s, M_p = M_p, prop_shared = prop_shared, rho = rho, noise = noise, fix_R = R)
  sumstats_select <- dataset$sumstats_select
  sumstats_fit <- dataset$sumstats_fit
  R_cde <- dataset$R_cde
  R_tce <- dataset$R_tce
  beta <- dataset$beta
  
  # Calculate the self-influence of each node to track during simulations.
  R_obs = get_observed(R_cde)
  self_norm = 1 + diag(R_obs)
  min_abs_self = min(abs(self_norm))
  min_self = min(self_norm)
  max_self = max(self_norm)
  
  selected_bimmer <- select_snps(sumstats_select, p_thresh = 5e-6, welch_thresh = 0, weight = TRUE)
  selected_standard <- select_snps(sumstats_select, p_thresh = 5e-8, welch_thresh = NULL)
  tce_res <- fit_tce(sumstats_fit, selected_bimmer, mr_method = "egger_w")
  n_tce_nans <- sum(is.na(tce_res$R_tce))
  mae_tce <- mean(abs(tce_res$R_tce - R_tce), na.rm=T)
  rmse_tce <- sqrt(mean((tce_res$R_tce - R_tce)**2, na.rm=T))
  mean_missing <- mean(abs(R_tce[is.na(tce_res$R_tce)]))
  max_row_missing <- max(rowSums(is.na(tce_res$R_tce)))
  max_col_missing <- max(colSums(is.na(tce_res$R_tce)))
  print(c(mae_tce, mean(purrr::map_int(selected_bimmer, function(x){length(x[["names"]])}))))

  methods = c("inspre", "exact", "mvmr")
  result <- foreach(method = methods, .combine = bind_rows) %do% {
    D_hat = NULL
    lambda = NULL
    if(method == "exact"){
      R_hat <- fit_exact(tce_res$R_tce)$R_hat
      R_hat <- array(R_hat, dim = c(D, D, 1))
    } else if (method == "mvmr") {
      R_hat <- fit_mvmr(sumstats_fit, selected_standard)$R_hat
      R_hat <- array(R_hat, dim = c(D, D, 1))
    } else if (method == "inspre"){
      weights <- inspre::make_weights(tce_res$SE_tce)
      cde_res <- fit_inspre(R_tce = tce_res$R_tce, W = weights, cv_folds = 5, verbose = 1, lambda_min_ratio = 0.1, nlambda = 25, warm_start = FALSE)
      R_hat <- cde_res$R_hat
      D_hat <- cde_res$D_hat
      lambda <- cde_res$lambda
    }
    metrics <- map_dfr(array_tree(R_hat, 3), function(t){calc_metrics(t, R_cde)})
    metrics$D_hat <- D_hat
    metrics$lambda <- lambda
    metrics$iter <- iter
    metrics$min_abs_self <- min_abs_self
    metrics$method <- method
    metrics$n_tce_nans <- n_tce_nans
    metrics$mean_missing <- mean_missing
    metrics$max_row_missing <- max_row_missing
    metrics$max_col_missing <- max_col_missing
    metrics$mae_tce <- mae_tce
    metrics$rmse_tce <- rmse_tce
    return(metrics)
  }
  return(result)
}
```


```{r}
# First simulation: ER graphs, random direction.
n_iter = 24
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "random"
prob = 0.04
g = NULL
v = 0.3
orient = "random"

rho = 0
noise = 0.8 # 20% heritability

doMC::registerDoMC(cores = n_cores)
plot_tibble_1 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
# for(iter in 1:n_iter){
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_1, file = "~/ukbb_network/plot_data/bimmer_sim_1.Rdata")
```


```{r}
# Second simulation: ER graphs, towards direction.
n_iter = 24
n_cores =24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "random"
prob = 0.04
g = NULL
v = 0.3
orient = "towards"

rho = 0
noise = 0.8 # 20% heritability

doMC::registerDoMC(cores = n_cores)
# plot_tibble_2 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
for(iter in 1:n_iter){
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_2, file = "~/ukbb_network/plot_data/bimmer_sim_2.Rdata")
```


```{r}
# Third simulation: ER graphs, away direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "random"
prob = 0.04
g = NULL
v = 0.3
orient = "away"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
# plot_tibble_3 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
for(iter in 1:n_iter){
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_3, file = "~/ukbb_network/plot_data/bimmer_sim_3.Rdata")
```


```{r}
# Fourth simulation: hub graphs, random direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "hub"
prob = NULL
g = 5
v = 0.3
orient = "random"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
plot_tibble_4 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_4, file = "~/ukbb_network/plot_data/bimmer_sim_4.Rdata")
```

```{r}
# Fifth simulation: hub graphs, towards direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "hub"
prob = NULL
g = 5
v = 0.3
orient = "towards"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
plot_tibble_5 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_5, file = "~/ukbb_network/plot_data/bimmer_sim_5.Rdata")
```

```{r}
# Sixth simulation: hub graphs, away direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "hub"
prob = 5
g = NULL
v = 0.3
orient = "away"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
plot_tibble_6 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_6, file = "~/ukbb_network/plot_data/bimmer_sim_6.Rdata")
```


```{r}
# Seventh simulation: scale-free graphs, random direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "scale-free"
prob = NULL
g = NULL
v = 0.3
orient = "random"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
plot_tibble_7 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_7, file = "~/ukbb_network/plot_data/bimmer_sim_7.Rdata")
```


```{r}
# Eigth simulation: scale-free graphs, towards direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "scale-free"
prob = NULL
g = NULL
v = 0.3
orient = "towards"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
plot_tibble_8 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_8, file = "~/ukbb_network/plot_data/bimmer_sim_8.Rdata")
```

```{r}
# Ninth simulation: scale-free graphs, away direction.
n_iter = 120
n_cores = 24
N = 100000
M_s = 1000
M_p = 4000
prop_shared = NULL
M_total = 1000000
D = 100
graph = "scale-free"
prob = NULL
g = NULL
v = 0.3
orient = "away"

rho = 0
noise = 0.8 # 20% heritability

methods = c("exact", "inspre", "mvmr")

doMC::registerDoMC(cores = n_cores)
plot_tibble_9 <- foreach(iter = 1:n_iter, .combine = bind_rows, .inorder = FALSE) %dopar% {
  run_methods(iter, N, D, M_total, M_s, M_p, prop_shared, rho, noise, graph, prob, g, v, orient)
}
save(plot_tibble_9, file = "~/ukbb_network/plot_data/bimmer_sim_9.Rdata")
```


## OLD ##
# ```{r}
# # Basic set-up for simulation.
# N = 10000
# M = 2000
# M_null = 100000
# D = 25
# C = 1
# sd_net = 0.5
# sd_beta = 0.5
# p_beta = 0.4
# p_net = 0.1
# pleiotropy = FALSE
# niter = 100
# sigma_g = 1
# 
# fit_method_functions <- list("exact" = fit_exact_function,
#                              "inspre_best" = fit_inspre_best_function,
#                              "inspre_mask" = fit_inspre_mask_function,
#                              "mvmr" = fit_mvmr_function)
# 
# doMC::registerDoMC(cores = 8)
# plot_tibble <- foreach(i = 1:niter, .combine = bind_rows) %dopar% {
#   # Randomly choose noise proportion.
#   noise <- runif(1, 0.1, 0.5)
#   conf_ratio <- runif(1, 0.1, 0.5)
#   total_noise <- conf_ratio*(1-noise) + noise
#   print(c(i, noise, conf_ratio, total_noise))
#   dataset <- generate_dataset(
#     N = N, M = M, D = D, C = C, noise = noise, sd_net = sd_net, p_net = p_net,
#     p_beta = p_beta, conf_ratio = conf_ratio, sigma_g = sigma_g,
#     pleiotropy = pleiotropy)
#   Y_sds <- apply(dataset$Y, 2, sd)
# 
#   # Calculate the self-influence of each node to track during simulations.
#   R_obs = get_observed(dataset$R)
#   self_norm = 1 + diag(R_obs)
#   min_abs_self = min(abs(self_norm))
#   min_self = min(self_norm)
#   max_self = max(self_norm)
# 
#   # All calculations happen on per-normalized scale, so convert R here.
#   R_tce = get_tce(R_obs, normalize=Y_sds)
#   R_normed <- fit_exact(R_tce)$R_hat
#   
#   print(c(max(abs(R_tce[!diag(D)])), max(abs(R_normed)), max(abs(dataset$R))))
# 
#   # Split dataset into SNP selection and fitting.
#   sample <- sample.int(n = N, size = floor(N/2), replace = FALSE)
#   X_select = dataset$X[sample, ]
#   Y_select = dataset$Y[sample, ]
#   X_fit = dataset$X[-sample, ]
#   Y_fit = dataset$Y[-sample, ]
#   sumstats_select = generate_sumstats(X_select, Y_select)
#   sumstats_fit = generate_sumstats(X_fit, Y_fit)
# 
#   # Select SNPs.
#   selected_bimmer <- select_snps(sumstats_select, p_thresh = 5e-04, welch_thresh = 0.1)
#   selected_standard <- select_snps(sumstats_select, p_thresh = 5e-7, welch_thresh = NULL)
# 
#   snp_methods <- list("standard" = selected_standard,
#                       "bimmer" = selected_bimmer)
# 
#   foreach(snp_method = names(snp_methods), .combine = bind_rows) %do% {
#   # for(snp_method in names(snp_methods)){
#     snps_to_use <- snp_methods[[snp_method]]
#     tce_res <- fit_tce(sumstats_fit, snps_to_use, mr_method = "egger_p")
#     n_tce_nans <- sum(is.na(tce_res$R_tce))
#     mae_tce <- mean(abs(tce_res$R_tce - R_tce), na.rm=T)
#     rmse_tce <- sqrt(mean((tce_res$R_tce - R_tce)**2, na.rm=T))
#     mean_missing <- mean(abs(R_tce[is.na(tce_res$R_tce)]))
#     max_row_missing <- max(rowSums(is.na(tce_res$R_tce)))
#     max_col_missing <- max(colSums(is.na(tce_res$R_tce)))
# 
#     foreach(fit_method = names(fit_method_functions), .combine = bind_rows) %do% {
#       print(c(snp_method, fit_method))
#       R_cde_hat <- fit_method_functions[[fit_method]](sumstats_fit, snps_to_use, tce_res)
#       metrics <- map_dfr(array_tree(R_cde_hat, 3), function(t){calc_metrics(t, R_normed)})
#       metrics <- metrics[which.max(metrics$F1), ]
#       metrics$iter <- i
#       metrics$noise <- noise
#       metrics$conf_ratio <- conf_ratio
#       metrics$total_noise <- total_noise
#       metrics$min_abs_self <- min_abs_self
#       metrics$snp_method <- snp_method
#       metrics$fit_method <- fit_method
#       metrics$n_tce_nans <- n_tce_nans
#       metrics$mean_missing <- mean_missing
#       metrics$max_row_missing <- max_row_missing
#       metrics$max_col_missing <- max_col_missing
#       metrics$mae_tce <- mae_tce
#       metrics$rmse_tce <- rmse_tce
#       print(metrics)
#     }
#   }
# }
# ```
# 
# 
# ```{r}
# well_cond <- plot_tibble %>% filter(min_abs_self > 0.1, max_row_missing < 10, max_col_missing < 10)
# 
# 
# 
# well_cond <- plot_tibble %>% filter(n_tce_nans < 45, !is.na(mr_method))
# ggplot(well_cond, aes(total_noise, mae_tce, colour = mr_method)) + geom_point() # + ylim(0, 0.5)
# ggplot(well_cond, aes(total_noise, mae_cde, colour = mr_fit)) + geom_point() # + ylim(0, 0.5)
# 
# ggplot(well_cond, aes(mr_method, mse_tce)) + geom_violin() + geom_jitter(height = 0, width = 0.1, alpha = 0.05)  + ylim(0, 0.5)
# ggplot(well_cond, aes(mr_fit, mse_cde)) + geom_violin() + geom_jitter(height = 0, width = 0.1, alpha = 0.05)  + ylim(0, 0.5) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
# 
# ggplot(well_cond, aes(mr_method, mae_tce)) + geom_violin() + geom_jitter(height = 0, width = 0.1, alpha = 0.05)#+ ylim(0, 0.5)
# ggplot(well_cond, aes(mr_fit, mae_cde)) + geom_violin() + geom_jitter(height = 0, width = 0.1, alpha = 0.05) + theme(axis.text.x = element_text(angle = 90, hjust = 1))# + ylim(0, 0.5)
# 
# ggplot(well_cond, aes(mr_method, mer_tce)) + geom_violin() + geom_jitter(height = 0, width = 0.1, alpha = 0.05) #+ ylim(-0.25, 0.25)
# ggplot(well_cond, aes(mr_fit, mer_cde)) + geom_violin() + geom_jitter(height = 0, width = 0.1, alpha = 0.05) #+ ylim(-0.25, 0.25) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
# 
# ggplot(well_cond, aes(conf_ratio, mer_tce, colour = mr_method)) + geom_point()
# ggplot(well_cond[sapply(well_cond["mr_fit"], function(x){x %in% c("cheat_regularized", "ps_regularized", "ps_shrunk_regularized")}),], aes(conf_ratio, mer_cde, colour = mr_fit)) + geom_point()
# ```
# 
# ```{r}
# # Try to see what's up with R_tce > 1??
# 
# ```
# 
# 
# ```{r warning = FALSE}
# # This simulation is for showing the re-sampling works to get the SE.
# # Basic set-up for simulation.
# N = 5000
# M = 1000
# D = 10
# C = 0
# sd_net = 0.5
# sd_beta = 1.0
# p_beta = 0.15
# p_net = 0.15
# symmetric = NULL
# pleiotropy = FALSE
# n_outer = 100
# n_inner = 50
# 
# sigma_g = matrix(1L, D, D)
# 
# plot_tibble <- foreach(i = 1:n_outer, .combine = bind_rows) %do% {
#   # Randomly choose number of resmamples.
#   n_resample = round(runif(1, 0, 100))
#   # Randomly choose noise proportion.
#   noise <- runif(1, 0, 0.7)
#   conf_ratio <- 0 # runif(1, 0, 0.5)
#   total_noise <- conf_ratio*(1-noise) + noise
#   print(c(i, noise, conf_ratio, total_noise))
#   R = generate_network(D, p_net, symmetric = symmetric, sd = sd_net)
#   beta = generate_beta(M, D, p_beta, pleiotropy = pleiotropy, sd = sd_beta)$beta
#   # Calculate the rank of R to track during simulations.
#   eigenv_R <- eigen(R, only.values = TRUE)$values
#   rank_R <- sum(abs(eigenv_R) > 1e-10)
#   # Calculate the self-influence of each nose to track during simulations.
#   R_obs = get_observed(R)
#   self_norm = 1 + diag(R_obs)
#   min_abs_self = min(abs(self_norm))
#   min_self = min(self_norm)
#   max_self = max(self_norm)
# 
#   # Just choose one pair for now, eventually this will be the "chosen" method.
#   foreach(mr_method = c("ps"),
#           .combine = bind_rows) %do% {
#     foreach(fit_method = c("regularized"),
#             .combine = bind_rows) %do% {
#       run_sum_tce = rep(0, length(R))
#       run_sum_sq_tce = rep(0, length(R))
#       run_sum_cde = rep(0, length(R))
#       run_sum_sq_cde = rep(0, length(R))
#       SE_cde_hat = matrix(0L, nrow = D, ncol = D)
#       SE_cde = matrix(0L, nrow = D, ncol = D)
#       SE_tce = matrix(0L, nrow = D, ncol = D)
#       rs_res = NULL
#       n_done = 0
#       for(j in 1:n_inner){
#         tryCatch({
#           dataset <- generate_dataset(N, M, D, C, noise = noise, conf_ratio = conf_ratio,
#                                       sigma_g = sigma_g, fix_R = R, fix_beta = beta)
#           Y_sds <- apply(dataset$Y, 2, sd)
#           # All calculations happen on per-normalized scale, so convert R here.
#           # Technically these will be slightly different on each iter, but for
#           # fixed beta and R Y_sds should have very low variance across runs.
#           R_tce = get_tce(R_obs, normalize=Y_sds)
#           R_normed <- fit_exact(R_tce)
# 
#           # Split dataset into SNP selection and fitting.
#           sample <- sample.int(n = N, size = floor(N/2), replace = FALSE)
#           X_select = dataset$X[sample, ]
#           Y_select = dataset$Y[sample, ]
#           X_fit = dataset$X[-sample, ]
#           Y_fit = dataset$Y[-sample, ]
#           sumstats_select = generate_sumstats(X_select, Y_select, normalize = TRUE)
#           sumstats_fit = generate_sumstats(X_fit, Y_fit, normalize = TRUE)
# 
#           # Select SNPs via sumstats and by cheating.
#           selected <- select_snps(sumstats_select)
#           selected_oracle <- select_snps_oracle(dataset$beta, sumstats_fit$p_value)
#   
#           if(mr_method == "ps_shrunk"){
#             tce_res <- fit_tce(sumstats_fit, selected_oracle, mr_method="ps", shrink = TRUE)
#           } else{
#             tce_res <- fit_tce(sumstats_fit, selected, mr_method=mr_method)
#           }
#           R_tce_hat <- tce_res$R_tce
#           SE_tce_hat <- tce_res$SE_tce
#           run_sum_tce = run_sum_tce + as.vector(R_tce_hat)
#           run_sum_sq_tce = run_sum_sq_tce + as.vector(R_tce_hat)^2
# 
#           
#           # We might have some missing values, for now impute with true + noise.
#           mae_tce <- mean(as.matrix(abs(R_tce - R_tce_hat)), na.rm=TRUE)
#           n_tce_nans = sum(is.na(R_tce_hat))
#           R_tce_hat[is.na(R_tce_hat)] = R_tce[is.na(R_tce_hat)] + 
#             rnorm(sum(is.na(R_tce_hat)), sd = 1.5*mae_tce)
#           SE_tce_hat[is.na(SE_tce_hat)] = 0
#       
#           fit_method_func <- switch(fit_method,
#             exact = fit_exact,
#             regularized = function(R_tce){
#               fit_regularized_over_lambda(R_tce, R_normed)},
#             pcor = function(R_tce){
#               cor2pcor(m = R_tce)
#             }
#           )
#           if(j == 1){
#             rs_res = resample_cde(R_tce_hat, SE_tce_hat, tce_res$N_obs,
#                                    fit_method_func, n_resample)
#             R_hat = rs_res$R_cde
#             SE_cde_hat = rs_res$SE_cde
#           } else {
#             R_hat = fit_method_func(R_tce = R_tce_hat)
#           }
#           run_sum_cde = run_sum_cde + as.vector(R_hat)
#           run_sum_sq_cde = run_sum_sq_cde + as.vector(R_hat)^2
# 
#           n_done = n_done + 1
#           R_cde_ave = run_sum_cde/n_done
#           SE_cde_next = matrix(sqrt((run_sum_sq_cde/n_done - R_cde_ave^2) * (n_done/(n_done - 1))), nrow = D)
#           R_tce_ave = run_sum_tce/n_done
#           SE_tce_next = matrix(sqrt((run_sum_sq_tce/n_done - R_tce_ave^2) * (n_done/(n_done - 1))), nrow = D)
#           
#           eps_cde = mean(abs(SE_cde - SE_cde_next))
#           eps_tce = mean(abs(SE_tce - SE_tce_next), na.rm = TRUE)
#           # print(c(j, eps_tce, eps_cde))
#           SE_cde = SE_cde_next
#           SE_tce = SE_tce_next
#         },
#         error = function(cond){
#           print(mr_method)
#           print(fit_method)
#           print(cond)
#         })
#       }
#       R_cde_ave = run_sum_cde/n_inner
#       SE_cde = matrix(sqrt((run_sum_sq_cde/n_inner - R_cde_ave^2) * (n_inner/(n_inner - 1))), nrow = D)
#       R_tce_ave = run_sum_tce/n_inner
#       SE_tce = matrix(sqrt((run_sum_sq_tce/n_inner - R_tce_ave^2) * (n_inner/(n_inner - 1))), nrow = D)
#   
#       mer_tce_se = mean(SE_tce_hat - SE_tce, na.rm = TRUE)
#       mae_tce_se = mean(abs(SE_tce_hat - SE_tce), na.rm = TRUE)
#       mer_cde_se = mean(SE_cde_hat - SE_cde)
#       mae_cde_se = mean(abs(SE_cde_hat - SE_cde))
#       tibble(iter = i, noise = noise, conf_ratio = conf_ratio, total_noise = total_noise,
#             min_abs_self = min_abs_self, rank_R = rank_R,
#             n_tce_nans = n_tce_nans, mr_method = mr_method,
#             fit_method = fit_method, mae_tce_se = mae_tce_se, mae_cde_se = mae_cde_se,
#             mer_tce_se = mer_tce_se, mer_cde_se = mer_cde_se)
#     }
#   }
# }
# plot_tibble = unite(plot_tibble, "mr_fit", c("mr_method", "fit_method"), sep = "_", remove = FALSE)
# ```
# 
# ```{r warning=FALSE}
# # This simulation is for showing the delta method works.
# # Basic set-up for simulation.
# N = 5000
# M = 1000
# D = 10
# C = 0
# sd_net = 0.8
# p_beta = 0.15
# p_net = 0.2
# symmetric = FALSE
# pleiotropy = FALSE
# niter = 1
# sigma_g = matrix(1L, D, D)
# n_resample = 100
# 
# plot_tibble <- foreach(i = 1:niter, .combine = bind_rows) %do% {
#   # Randomly choose noise proportion.
#   noise <- runif(1, 0, 0.7)
#   conf_ratio <- 0 # runif(1, 0, 0.5)
#   total_noise <- conf_ratio*(1-noise) + noise
#   print(c(i, noise, conf_ratio, total_noise))
#   dataset <- generate_dataset(N, M, D, C, noise = noise, sd_net = sd_net, p_net = p_net, p_beta = p_beta,
#                               symmetric = symmetric, conf_ratio = conf_ratio, sigma_g = sigma_g, pleiotropy = pleiotropy)
#   Y_sds <- apply(dataset$Y, 2, sd)
# 
#   # Calculate the rank of R to track during simulations.
#   eigenv_R <- eigen(dataset$R, only.values = TRUE)$values
#   rank_R <- sum(abs(eigenv_R) > 1e-10)
# 
#   # Calculate the self-influence of each nose to track during simulations.
#   R_obs = get_observed(dataset$R)
#   self_norm = 1 + diag(R_obs)
#   min_abs_self = min(abs(self_norm))
#   min_self = min(self_norm)
#   max_self = max(self_norm)
# 
#   # All calculations happen on per-normalized scale, so convert R here.
#   R_tce = get_tce(R_obs, normalize=Y_sds)
#   R_normed <- fit_exact(R_tce)
# 
#   # Split dataset into SNP selection and fitting.
#   sample <- sample.int(n = N, size = floor(N/2), replace = FALSE)
#   X_select = dataset$X[sample, ]
#   Y_select = dataset$Y[sample, ]
#   X_fit = dataset$X[-sample, ]
#   Y_fit = dataset$Y[-sample, ]
#   sumstats_select = generate_sumstats(X_select, Y_select)
#   sumstats_fit = generate_sumstats(X_fit, Y_fit, normalize = TRUE)
# 
#   # Select SNPs via sumstats and by cheating.
#   selected <- select_snps(sumstats_select)
#   selected_oracle <- select_snps_oracle(dataset$beta, sumstats_fit$p_value)
#   
#   # Run all combinations of MR method and fit method.
#   mr_method = "ps"
#   fit_method = "exact"
#       tryCatch(
#         {
#           tce_res <- fit_tce(sumstats_fit, selected, mr_method=mr_method)
#           R_tce_hat <- tce_res$R_tce
#           SE_tce_hat <- tce_res$SE_tce
# 
#           mer_tce <- mean(as.matrix(R_tce - R_tce_hat), na.rm=TRUE)
#           mae_tce <- mean(as.matrix(abs(R_tce - R_tce_hat)), na.rm=TRUE)
#           mse_tce <- mean(as.matrix(abs(R_tce - R_tce_hat)**2), na.rm=TRUE)
#       
#           # We might have some missing values, for now impute with true + noise.
#           n_tce_nans = sum(is.na(R_tce_hat))
#           R_tce_hat[is.na(R_tce_hat)] = R_tce[is.na(R_tce_hat)] + 
#             rnorm(sum(is.na(R_tce_hat)), sd = 1.5*mae_tce)
#           SE_tce_hat[is.na(SE_tce_hat)] = 0
#       
#           fit_method_func <- switch(fit_method,
#             exact = fit_exact,
#             reg_cheat = function(R_tce){
#               fit_regularized_over_lambda(R_tce, R_normed)
#             },
#             reg_auto = function(R_tce){
#               fit_regularized_auto(R_tce)$R_hat
#             },
#             reg_auto_same = function(R_tce){
#               fit_regularized_auto_same(R_tce)$R_hat
#             },
#             pcor = function(R_tce){
#               cor2pcor(m = R_tce)
#             }
#           )
#           rs_res = resample_cde(R_tce_hat, SE_tce_hat,
#                                 fit_method_func, n_resample)
#           SE_cde = rs_res$SE_cde
# 
#           SE_cde_hat = delta_cde(solve(R_tce_hat), SE_tce_hat)
#           
#           mer_cde_se = mean(SE_cde_hat - SE_cde)
#           mae_cde_se = mean(abs(SE_cde_hat - SE_cde))
#           print(mae_cde_se)
#           tibble(iter = i, noise = noise, conf_ratio = conf_ratio, total_noise = total_noise,
#             min_abs_self = min_abs_self, rank_R = rank_R,
#             n_tce_nans = n_tce_nans, mr_method = mr_method,
#             fit_method = fit_method, mae_cde_se = mae_cde_se,
#             mer_cde_se = mer_cde_se)
#         },
#         error = function(cond){
#           print(mr_method)
#           print(fit_method)
#           print(cond)
#         })
#   }
# plot_tibble = unite(plot_tibble, "mr_fit", c("mr_method", "fit_method"), sep = "_", remove = FALSE)
# well_cond = plot_tibble[(plot_tibble[,"n_tce_nans"] < 30),]
# ```
